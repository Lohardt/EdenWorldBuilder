//
//  TerrainChunk.m
//  Eden - World Builder
//  
// 
//  
//

#import "TerrainChunk.h"

#import "Liquids.h"
#import "Terrain.h"

@implementation TerrainChunk
@synthesize pbounds,prbounds,rtn_vertices,rtn_vertices2,pblocks,needsRebuild,needsGen,objects,rtnum_objects,idxn,loaded;
@synthesize pcolors;
const GLshort cubeTexture[] = {
	
	1,1,
	1,0,
	0,1,	
	0,1,
	1,0,
	0,0,
	
	0,1,
	1,1,
	0,0,	
	0,0,
	1,1,
	1,0,
	
	0,1,
	1,1,
	0,0,	
	0,0,
	1,1,
	1,0,
	
	
	1,1,
	1,0,
	0,1,	
	0,1,
	1,0,
	0,0,
	
	
	
	0,1,
	1,1,
	0,0,	
	0,0,
	1,1,
	1,0,
	
	
	1,1,
	1,0,
	0,1,	
	0,1,
	1,0,
	0,0,	
};
GLshort liquidTexture[2*6*6]={
    1,1,
	1,0,
	0,1,	
	0,1,
	1,0,
	0,0,
	
	0,1,
	1,1,
	0,0,	
	0,0,
	1,1,
	1,0,
	
	0,1,
	1,1,
	0,0,	
	0,0,
	1,1,
	1,0,
	
	
	1,1,
	1,0,
	0,1,	
	0,1,
	1,0,
	0,0,
	
	
	
	0,1,
	1,1,
	0,0,	
	0,0,
	1,1,
	1,0,
	
	
	1,1,
	1,0,
	0,1,	
	0,1,
	1,0,
	0,0,	
};

GLshort side2ShortVertices[3*6*6];
GLshort side3ShortVertices[3*6*6];
GLshort side4ShortVertices[3*6*6];
GLshort side2Texture[2*6*6];
GLshort side3Texture[2*6*6];
GLshort side4Texture[2*6*6];
const GLshort side1Texture[] = {
	
	1,1,    //front face
	1,0,
	0,1,	
	0,1,
	1,0,
	0,0,
	
	0,1,    //back face
	1,1,
	0,0,	
	0,0,
	1,1,
	1,0,
	
	1,1,    //left face
	1,0,
	0,1,	
   
	
	0,1,
     1,0,
    0,0,
	
	
        
	1,1,    //right face
	1,0,
	0,1,	
	0,1,
	1,0,
	0,0,
	
	
	
	0,1,    //bot face
	1,1,
	0,0,	
	0,0,
	1,1,
	1,0,
	
	
	1,1,    //top face
	1,0,
	0,1,	
	0,1,
	1,0,
	0,0,
};
const GLshort side1ShortVertices[] = {
	-9,-9,-9, //front face
	-9,-9,-9,
	-9,-9,-9,
	-9,-9,-9,
	-9,-9,-9,
	-9,-9,-9,
    
   /* 0,0,0, //front face
	0,1,0,
	1,0,0,
	1,0,0,
	0,1,0,
	1,1,0,*/
	
	
	0,0,1, //back face
	1,0,1,	
	0,1,1,	
	0,1,1,
	1,0,1,
	1,1,1,	
	
	
	0,0,1, //left face
	0,1,1,
	1,0,0,	
	1,0,0,
	0,1,1,
	1,1,0,
	
	
	1,0,0, //right face
	1,1,0,
	1,0,1,
	1,0,1,
	1,1,0,
	1,1,1,	
	
	-9,-9,-9, //bot face
	-9,-9,-9,
	-9,-9,-9,	
	0,0,1,
	1,0,0,
	1,0,1,
	
	
	-9,-9,-9, //top face
	-9,-9,-9,
	-9,-9,-9,
	1,1,0,
	0,1,1,	
	1,1,1
};


GLshort ramp2ShortVertices[3*6*6];
GLshort ramp3ShortVertices[3*6*6];
GLshort ramp4ShortVertices[3*6*6];
GLshort ramp2Texture[2*6*6];
GLshort ramp3Texture[2*6*6];
GLshort ramp4Texture[2*6*6];

const GLshort ramp1Texture[] = {
	
	1,1,//front face
	1,0,
	0,1,	
	0,1,
	1,0,
	0,0,
	
	0,1,//back face
	1,1,
	0,0,	
	0,0,
	1,1,
	1,0,
	
	0,1,//left face
	1,1,
	0,0,	
	0,1,
	1,1,
	1,0,
	
	
	1,1,//right face
	1,0,
	0,1,	
	0,1,
	1,1,
	0,0,
	
	
	
	0,1,//bot face
	1,1,
	0,0,	
	0,0,
	1,1,
	1,0,
	
	
	1,1,//top face
	1,0,
	0,1,	
	0,1,
	1,0,
	0,0,
	
	
	
	
	
	
	
};
const GLshort ramp1ShortVertices[] = {
/*	0,0,0, //front face
	0,1,0,
	1,0,0,
	1,0,0,
	0,1,0,
	1,1,0,*/
    
    	-9,-9,-9, //front face
     -9,-9,-9,
     -9,-9,-9,
     -9,-9,-9,
    -9,-9,-9,
     -9,-9,-9,
	
	
	0,0,1, //back face
	1,0,1,	
	0,1,1,	
	0,1,1,
	1,0,1,
	1,1,1,	
	
	
	-9,-9,-9, //left face
	-9,-9,-9,
	-9,-9,-9,
    0,0,0,
    0,0,1,
	0,1,1,
	
	
	
	
	
	-9,-9,-9, //right face
	-9,-9,-9,
	-9,-9,-9,
	1,0,1,
	1,0,0,
	1,1,1,	
	
	0,0,0, //bot face
	1,0,0,
	0,0,1,	
	0,0,1,
	1,0,0,
	1,0,1,
	
    0,0,0, //top face
	0,1,1,
	1,0,0,
	1,0,0,
	0,1,1,	
	1,1,1
	
	
};


const GLshort cubeShortVertices[] = {
	0,0,0, //front face
	0,1,0,
	1,0,0,
	1,0,0,
	0,1,0,
	1,1,0,
	
	
	0,0,1, //back face
	1,0,1,	
	0,1,1,	
	0,1,1,
	1,0,1,
	1,1,1,	
	
	
	0,0,0, //left face
	0,0,1,
	0,1,0,	
	0,1,0,
	0,0,1,
	0,1,1,
	
	
	1,0,0, //right face
	1,1,0,
	1,0,1,
	1,0,1,
	1,1,0,
	1,1,1,	
	
	0,0,0, //bot face
	1,0,0,
	0,0,1,	
	0,0,1,
	1,0,0,
	1,0,1,
	
	
	0,1,0, //top face
	0,1,1,
	1,1,0,
	1,1,0,
	0,1,1,	
	1,1,1
};

GLshort liquidCube[] = {
	0,0,0, //front face
	0,4,0,
	4,0,0,
	4,0,0,
	0,4,0,
	4,4,0,
	
	
	0,0,4, //back face
	4,0,4,	
	0,4,4,	
	0,4,4,
	4,0,4,
	4,4,4,	
	
	
	0,0,0, //left face
	0,0,4,
	0,4,0,	
	0,4,0,
	0,0,4,
	0,4,4,
	
	
	4,0,0, //right face
	4,4,0,
	4,0,4,
	4,0,4,
	4,4,0,
	4,4,4,	
	
	0,0,0, //bot face
	4,0,0,
	0,0,4,	
	0,0,4,
	4,0,0,
	4,0,4,
	
	
	0,4,0, //top face
	0,4,4,
	4,4,0,
	4,4,0,
	0,4,4,	
	4,4,4
};
/*
const GLfloat cubeVertices[] = {
	0,0,0, //front face
	0,1,0,
	1,0,0,
	1,0,0,
	0,1,0,
	1,1,0,
	
	
	0,0,1, //back face
	1,0,1,	
	0,1,1,	
	0,1,1,
	1,0,1,
	1,1,1,	
	
	
	0,0,0, //left face
	0,0,1,
	0,1,0,	
	0,1,0,
	0,0,1,
	0,1,1,
	
	
	1,0,0, //right face
	1,1,0,
	1,0,1,
	1,0,1,
	1,1,0,
	1,1,1,	
	
	0,0,0, //bot face
	1,0,0,
	0,0,1,	
	0,0,1,
	1,0,0,
	1,0,1,
	
	
	0,1,0, //top face
	0,1,1,
	1,1,0,
	1,1,0,
	0,1,1,	
	1,1,1
};*/
/*static short ramptopface[]={	
    0,1,0, //high left to low right
    0,1,1,
    1,0,0,
    1,0,0,
    0,1,1,	
    1,0,1,
    
    
    0,1,0, //high front to low back
    0,0,1,
    1,1,0,
    1,1,0,
    0,0,1,	
    1,0,1,
    
    
    0,0,0, //high right to low left
    0,0,1,
    1,1,0,
    1,1,0,
    0,0,1,	
    1,1,1,
    
    0,0,0, //high back to low front
    0,1,1,
    1,0,0,
    1,0,0,
    0,1,1,	
    1,1,1,
};*/
const static GLubyte cubeColors[] = {
	216,216,216, 
	140,140,140,
	191,191,191,
	114,114,114,
	153,153,153,
	255,255,255,
	

};
const static GLfloat zzzzColors[] = {
	1,1,1, //front face
	1,1,1,
	1,1,1,
	1,1,1,
	1,1,1,
	1,1,1,
	
	.5f,.5f,.5f, //back face
	.5f,.5f,.5f,
	.5f,.5f,.5f,
	.5f,.5f,.5f,
	.5f,.5f,.5f,
	.5f,.5f,.5f,
		
	
	.7f,.7f,.7f, //left face
	.7f,.7f,.7f,
	.7f,.7f,.7f,
	.7f,.7f,.7f,
	.7f,.7f,.7f,
	.7f,.7f,.7f,
	
	.4f,.4f,.4f, //right face
	.4f,.4f,.4f,
	.4f,.4f,.4f,
	.4f,.4f,.4f,
	.4f,.4f,.4f,
	.4f,.4f,.4f,
	
	.3f,.3f,.3f, //bot face
	.3f,.3f,.3f,
	.3f,.3f,.3f,
	.3f,.3f,.3f,
	.3f,.3f,.3f,
	.3f,.3f,.3f,
	
	.9f,.9f,.9f, //top face
	.9f,.9f,.9f,
	.9f,.9f,.9f,
	.9f,.9f,.9f,
	.9f,.9f,.9f,
	.9f,.9f,.9f

	
};

const GLfloat cubeNormals[] = {
	0,0,-1, //front face
	0,0,-1,
	0,0,-1,
	0,0,-1,
	0,0,-1,
	0,0,-1,	
	
	0,0,1, //back face
	0,0,1,
	0,0,1,
	0,0,1,
	0,0,1,
	0,0,1,	
	
	-1,0,0, //left face
	-1,0,0,
	-1,0,0,
	-1,0,0,
	-1,0,0,
	-1,0,0,	
	
	1,0,0, //right face
	1,0,0,
	1,0,0,
	1,0,0,
	1,0,0,
	1,0,0,	
	
	0,-1,0, //bot face
	0,-1,0,
	0,-1,0,
	0,-1,0,
	0,-1,0,
	0,-1,0,	
	
	0,1,0, //top face
	0,1,0,
	0,1,0,
	0,1,0,
	0,1,0,
	0,1,0
	
};



extern Vector colorTable[256];
static int v_idx=0;

static int v_idx2=0;
static Terrain* ter;
#define INDICES_MAX 32768
static unsigned short allIndices[INDICES_MAX ];
void tc_initGeometry(){
    
    for(int i=0;i<INDICES_MAX;i++)allIndices[i]=i;
    for(int f=0;f<6;f++)
    for(int i=0,j=0;i<6*3;i+=3,j+=2){
        int v=f*(6*3)+i;
        int v2;
        int nf=f;
        if(f==0)nf=2;
        if(f==1)nf=3;
        if(f==2)nf=1;
        if(f==3)nf=0;
        v2=nf*(6*3)+i;
        side2ShortVertices[v2]=side1ShortVertices[v+2];
        side2ShortVertices[v2+2]=-side1ShortVertices[v]+1;
        side2ShortVertices[v2+1]=side1ShortVertices[v+1];
        ramp2ShortVertices[v2]=ramp1ShortVertices[v+2];
        ramp2ShortVertices[v2+2]=-ramp1ShortVertices[v]+1;
        ramp2ShortVertices[v2+1]=ramp1ShortVertices[v+1];
        ramp2Texture[nf*(6*2)+j]=ramp1Texture[f*(6*2)+j];
        ramp2Texture[nf*(6*2)+j+1]=ramp1Texture[f*(6*2)+j+1];
        side2Texture[nf*(6*2)+j]=side1Texture[f*(6*2)+j];
        side2Texture[nf*(6*2)+j+1]=side1Texture[f*(6*2)+j+1];
        if(f==5){
            side2Texture[nf*(6*2)+j]=side1Texture[f*(6*2)+j+1];
            side2Texture[nf*(6*2)+j+1]=-side1Texture[f*(6*2)+j]+1;
        }else if(f==4){
            side2Texture[nf*(6*2)+j]=-side1Texture[f*(6*2)+j+1]+1;
            side2Texture[nf*(6*2)+j+1]=side1Texture[f*(6*2)+j];
        }
        
        nf=f;
        if(f==0)nf=1;
        if(f==1)nf=0;
        if(f==2)nf=3;
        if(f==3)nf=2;
         v2=nf*(6*3)+i;
        side3ShortVertices[v2]=-side1ShortVertices[v]+1;
        side3ShortVertices[v2+2]=-side1ShortVertices[v+2]+1;
        side3ShortVertices[v2+1]=side1ShortVertices[v+1];
        ramp3ShortVertices[v2]=-ramp1ShortVertices[v]+1;
        ramp3ShortVertices[v2+2]=-ramp1ShortVertices[v+2]+1;
        ramp3ShortVertices[v2+1]=ramp1ShortVertices[v+1];
        ramp3Texture[nf*(6*2)+j]=ramp1Texture[f*(6*2)+j];
        ramp3Texture[nf*(6*2)+j+1]=ramp1Texture[f*(6*2)+j+1];
        side3Texture[nf*(6*2)+j]=side1Texture[f*(6*2)+j];
        side3Texture[nf*(6*2)+j+1]=side1Texture[f*(6*2)+j+1];
        if(f==4||f==5){
            side3Texture[nf*(6*2)+j]=-side1Texture[f*(6*2)+j]+1;
            side3Texture[nf*(6*2)+j+1]=-side1Texture[f*(6*2)+j+1]+1;
        }
        
        nf=f;
        if(f==0)nf=3;
        if(f==1)nf=2;
        if(f==2)nf=0;
        if(f==3)nf=1;
        
         v2=nf*(6*3)+i;
        side4ShortVertices[v2]=-side1ShortVertices[v+2]+1;
        side4ShortVertices[v2+2]=side1ShortVertices[v];
        side4ShortVertices[v2+1]=side1ShortVertices[v+1];
        ramp4ShortVertices[v2]=-ramp1ShortVertices[v+2]+1;
        ramp4ShortVertices[v2+2]=ramp1ShortVertices[v];
        ramp4ShortVertices[v2+1]=ramp1ShortVertices[v+1];
        ramp4Texture[nf*(6*2)+j]=ramp1Texture[f*(6*2)+j];
        ramp4Texture[nf*(6*2)+j+1]=ramp1Texture[f*(6*2)+j+1];
        side4Texture[nf*(6*2)+j]=side1Texture[f*(6*2)+j];
        side4Texture[nf*(6*2)+j+1]=side1Texture[f*(6*2)+j+1];
        if(f==5){
            side4Texture[nf*(6*2)+j]=-side1Texture[f*(6*2)+j+1]+1;
            side4Texture[nf*(6*2)+j+1]=side1Texture[f*(6*2)+j];
        }else if(f==4){
            side4Texture[nf*(6*2)+j]=side1Texture[f*(6*2)+j+1];
            side4Texture[nf*(6*2)+j+1]=-side1Texture[f*(6*2)+j]+1;
        }

    }
    
}
-(id) initWithBlocks:(const int*)boundz:(int)rrcx:(int)rrcz:(Terrain*)terrain:(BOOL)genblocks{
	if(genblocks){
		pblocks=blocks;
		memset(blocks,0,sizeof(block8)*CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE);
       
        
	}
    
    needsVBO=FALSE;
    memset(sblocks,0,sizeof(SmallBlock*)*CHUNK_SIZE3);
    pcolors=colors;
    memset(colors,0,sizeof(color8)*CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE);
    indices=NULL;
    rtindices=NULL;
	ter=terrain;
	vertexBuffer=vertexBuffer2=elementBuffer=0;
	rcx=rrcx;
	rcz=rrcz;
    num_objects=0;
	pbounds=bounds;
	prbounds=rbounds;
	for(int i=0;i<6;i++){
		bounds[i]=boundz[i];
		rbounds[i]=(float)bounds[i]*BLOCK_SIZE;
		
	}
   

    isTesting=0;
	n_vertices=0;
    n_vertices2=0;
    needsRebuild=FALSE;//just a flag for terrain to use right now, not used internally
    
    loaded=TRUE;
	return self;
}
-(id) init:(const int*)boundz:(int)rrcx:(int)rrcz:(Terrain*)terrain{
	
    needsGen=FALSE;
	
   	return [self initWithBlocks:boundz:rrcx:rrcz:terrain:TRUE];
}
-(void)setBounds:(int*) boundz{
	for(int i=0;i<6;i++){
		bounds[i]=boundz[i];
        rtbounds[i]=boundz[i];
		rbounds[i]=(float)bounds[i]*BLOCK_SIZE;		
	}	
}
-(void)doGen{
    return;
/*    int type;
#define if_is_grass(x,z,y)\
type=[self getLand:x:z:y];\
if(type==TYPE_GRASS||type==TYPE_GRASS2||type==TYPE_GRASS3)
    
	for(int x=-1;x<CHUNK_SIZE+1;x++){
        for(int z=-1;z<CHUNK_SIZE+1;z++){
            for(int y=0;y<CHUNK_SIZE;y++){
                if([self getLand:x :z :y]==TYPE_NONE){
                    if_is_grass(x,z,y-1){
                        BOOL gtable[3][3];
                        for(int i=0;i<3;i++)
                            for(int j=0;j<3;j++){
                                if_is_grass(x+i-1,z+j-1,y)
                                gtable[i][j]=TRUE;
                                else
                                    gtable[i][j]=FALSE;
                            }
                        
                        if(gtable[2][0])
                            [self setLand:x:z:y:TYPE_GRASS_OUTSIDE_TRIM1];
                        if(gtable[2][2])
                            [self setLand:x:z:y:TYPE_GRASS_OUTSIDE_TRIM2];
                        if(gtable[0][2])
                            [self setLand:x:z:y:TYPE_GRASS_OUTSIDE_TRIM3];
                        if(gtable[0][0])
                            [self setLand:x:z:y:TYPE_GRASS_OUTSIDE_TRIM4];
                        
                        if(gtable[1][2]&&gtable[0][1])
                            [self setLand:x:z:y:TYPE_GRASS_INSIDE_TRIM1];
                        if(gtable[0][1]&&gtable[1][0])
                            [self setLand:x:z:y:TYPE_GRASS_INSIDE_TRIM2];
                        if(gtable[1][0]&&gtable[2][1])
                            [self setLand:x:z:y:TYPE_GRASS_INSIDE_TRIM3];
                        if(gtable[1][2]&&gtable[2][1])
                            [self setLand:x:z:y:TYPE_GRASS_INSIDE_TRIM4];
                        
                        if(gtable[2][1]&&!gtable[1][0]&&!gtable[1][2])
                            [self setLand:x:z:y:TYPE_GRASS_RAMP4];
                        
                        if(gtable[1][2]&&!gtable[0][1]&&!gtable[2][1])
                            [self setLand:x:z:y:TYPE_GRASS_RAMP1];
                        
                        if(gtable[0][1]&&!gtable[1][0]&&!gtable[1][2])
                            [self setLand:x:z:y:TYPE_GRASS_RAMP2];
                        
                        if(gtable[1][0]&&!gtable[0][1]&&!gtable[2][1])
                            [self setLand:x:z:y:TYPE_GRASS_RAMP3];
                        //3  2
                        //0  1
                        
                        
                        
                        
                        
                        
                    }
                }
            }
        }
    }
 */
    
}
static int face_visibility[CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE];
static Vector lighting[CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE]; 
static short face_size[CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE*6];

static vertexStructSmall vertices[CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE*6*6];
static vertexStructSmall vertices2[CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE*6*6];



//static int count=0;
extern BurnNode* burnList;
static int angledFace[TYPE_ICE_SIDE4-TYPE_STONE_RAMP1+1]={
    5,5,5,5,
    5,5,5,5,
    5,5,5,5,
    5,5,5,5,
   
    
    2,0,3,1,
    2,0,3,1,
    2,0,3,1,
    2,0,3,1,
    
};
#define FACE_FRONT (1<<0)
#define FACE_BACK (1<<1)
#define FACE_LEFT (1<<2)
#define FACE_RIGHT (1<<3)
#define FACE_BOTTOM (1<<4)
#define FACE_TOP (1<<5)
#define FACE_ALL 0b111111
#define RAMP1 0
#define RAMP2 1
#define RAMP3 2
#define RAMP4 3
#define SIDE1 4
#define SIDE2 5
#define SIDE3 6
#define SIDE4 7
static int ugly_var_type=0;
//static WetNode* ugly_node;

extern map_t wetmap;
extern bool isRampFaceSolid[4][6];
extern bool isSideFaceSolid[4][6];

const static int dx[6]={-1,1,0,0,0,0};
const static int dy[6]={0,0,-1,1,0,0};
const static int dz[6]={0,0,0,0,-1,1};
const static int dz2[6]={-1,1,0,0,0,0};
const static int dx2[6]={0,0,-1,1,0,0};
const static int dy2[6]={0,0,0,0,-1,1};
extern const GLubyte blockColor[NUM_BLOCKS+1][3];
bool isSolid(int x,int z,int y,int d);
inline bool isSolid(int x,int z,int y,int d){  
    const static int dx[]={1,0,-1,0,0,0};
    const static int dz[]={0,1,0,-1,0,0};
    const static int dy[]={0,0,0,0,-1,1};
    
    int type=getLandc(x+dx[d],z+dz[d],y+dy[d]);
    if(type==TYPE_NONE)return false;
    if(type<0)return true;
    
    if(ugly_var_type>=TYPE_STONE_RAMP1&&ugly_var_type<=TYPE_ICE_SIDE4){ 
        if(ugly_var_type<=TYPE_ICE_RAMP4){  
            if(d<4){
                if(!isRampFaceSolid[ugly_var_type%4][(d+2)%4])
                    return false;
                
            }else{
                if(!isRampFaceSolid[ugly_var_type%4][(d+1)%2+4])
                    return false;
            }
        }else {
            if(d<4){
                if(!isSideFaceSolid[ugly_var_type%4][(d+2)%4])
                    return false;
                
            }else{
                if(!isSideFaceSolid[ugly_var_type%4][(d+1)%2+4])
                    return false;
            }
        }
    }
    
    if((type>=TYPE_STONE_RAMP1&&type<=TYPE_ICE_SIDE4)||(blockinfo[type]&IS_ATLAS2)){ 
        if(type>=TYPE_STONE_RAMP1&&type<=TYPE_ICE_RAMP4){            
            return isRampFaceSolid[type%4][d];
        }else if(type>=TYPE_STONE_SIDE1&&type<=TYPE_ICE_SIDE4){           
            return isSideFaceSolid[type%4][d];
        }else if(blockinfo[type]&IS_ATLAS2){
            if(ugly_var_type==type&&[[World getWorld].terrain getColor:x :z :y]==[[World getWorld].terrain getColor:x+dx[d] :z+dz[d] :y+dy[d]])
                return true;
        }
    }
    return true;    
}
static bool hasBlocky[CHUNK_SIZE];
static bool hasVisy[CHUNK_SIZE];


extern block8* blockarray;

extern int genLevel(int type,int level);
extern int getLevel(int type);
extern int getBaseType(int type);
extern int g_offcx;
extern int g_offcz;
- (void)rebuild2{   //here be dragons//
    needsGen=FALSE;
    needsVBO=FALSE;
    v_idx=0;
    v_idx2=0;
    for(int i=0;i<7;i++){
        num_vertices[i]=0;
        num_vertices2[i]=0;
        face_idx[i]=0;
        face_idx2[i]=0;
    }
	[self clearMeshes];
    memset(hasBlocky,0,sizeof(bool)*CHUNK_SIZE);
    memset(lighting,0,sizeof(Vector)*CHUNK_SIZE);
    for(int y=0;y<CHUNK_SIZE;y++){
        for(int x=0;x<CHUNK_SIZE;x++){
            
			for(int z=0;z<CHUNK_SIZE;z++){
                lighting[(x)*CHUNK_SIZE*CHUNK_SIZE+(z)*CHUNK_SIZE+(y)]=MakeVector(0,0,0);
            }
        }
    }
    bool hasSeeThrough=FALSE;
    bool hasAnything=FALSE;
    for(int y=0;y<CHUNK_SIZE;y++){
        for(int x=0;x<CHUNK_SIZE;x++){
            
			for(int z=0;z<CHUNK_SIZE;z++){
                
				int type=blocks[x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+y];
                
				if(type<0||type>NUM_BLOCKS){
					[self setLand:x:z:y:TYPE_STONE];
                    
                    hasAnything=TRUE;
                    hasBlocky[y]=TRUE;
					
				}else if(blockinfo[type]&IS_ATLAS2){
                    hasSeeThrough=TRUE;
                    hasAnything=TRUE;
                    hasBlocky[y]=TRUE;
                }else if(type==TYPE_CUSTOM){
                    
                    SmallBlock* sb=sblocks[x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+y];
                    if(sb==NULL){
                        sblocks[x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+y]=sb=malloc(sizeof(SmallBlock));
                    }
                    for(int i=0;i<8;i++){
                        if(arc4random()%2==0)sb->blocks[i]=0;
                        else{
                            
                            sb->blocks[i]=arc4random()%NUM_BLOCKS;
                            if(blockinfo[sb->blocks[i]]&IS_OBJECT)sb->blocks[i]=TYPE_NONE;
                            
                            if(arc4random()%2==0)sb->colors[i]=0;
                            else sb->colors[i]=arc4random()%30;
                            
                        }
                        
                        
                    }
                    
                    hasSeeThrough=TRUE;
                    hasAnything=TRUE;
                    hasBlocky[y]=TRUE;
                }else if(type==TYPE_LIGHTBOX){
                    Vector color=colorTable[colors[x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+y]];
                    if(colors[x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+y]==0){
                        color=MakeVector(blockColor[type][0]/255.0f,blockColor[type][1]/255.0f,blockColor[type][2]/255.0f);
                    }int r=6;
                    for(int dx=-r;dx<=r;dx++){
                        for(int dz=-r;dz<=r;dz++){
                            for(int dy=-r;dy<=r;dy++){
                                if(dx+x<0||dx+x>=CHUNK_SIZE||dy+y<0||dy+y>=CHUNK_SIZE||dz+z<0||dz+z>=CHUNK_SIZE)continue;
                                int type=blocks[(x+dx)*CHUNK_SIZE*CHUNK_SIZE+(z+dz)*CHUNK_SIZE+(y+dy)];
                                if(type==TYPE_NONE||type==TYPE_LIGHTBOX)continue;
                                int min=MAX(MAX(ABS(dx),ABS(dz)),ABS(dy));
                                if(min<=0||min>r)continue;      
                                float strength=((float)r-(min-1))/(float)r;
                                //  strength*=strength;
                                Vector v=lighting[(x+dx)*CHUNK_SIZE*CHUNK_SIZE+(z+dz)*CHUNK_SIZE+(y+dy)];
                                
                                v.x+=color.x*strength;
                                v.y+=color.y*strength;
                                v.z+=color.z*strength;
                                if(v.x>1)v.x=1;
                                if(v.y>1)v.y=1;
                                if(v.z>1)v.z=1;
                                if(v.x!=0||v.y!=0||v.z!=0){
                                    //  printf("strength: %f\n",strength);
                                }
                                lighting[(x+dx)*CHUNK_SIZE*CHUNK_SIZE+(z+dz)*CHUNK_SIZE+(y+dy)]=v;
                            }
                        }
                    }
                    hasBlocky[y]=TRUE;
                    hasAnything=TRUE;
                }else if(type!=0){
                    hasBlocky[y]=TRUE;
                    hasAnything=TRUE;
                    if(type==TYPE_DOOR_TOP||type==TYPE_GOLDEN_CUBE||type==TYPE_FLOWER||type==TYPE_PORTAL_TOP){
                        num_objects++;
                    }
                }
			}
			
		}
	}
    if(!hasAnything){//printf("return early 1\n");
        return;}
    hasAnything=FALSE;
    memset(face_visibility,0,sizeof(int)*CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE);
    memset(hasVisy,0,sizeof(bool)*CHUNK_SIZE);
    int ex=bounds[0]+CHUNK_SIZE;
    int ez=bounds[2]+CHUNK_SIZE;
    int ey=bounds[1]+CHUNK_SIZE;
    
    
    if(hasSeeThrough){
        for(int gy=bounds[1];gy<ey;gy++){
            if(!hasBlocky[gy-bounds[1]])continue;
            for(int gx=bounds[0];gx<ex;gx++){
                
                for(int gz=bounds[2];gz<ez;gz++){
                    int idx1=((gx+g_offcx)%T_SIZE)*T_SIZE*T_HEIGHT+((gz+g_offcz)%T_SIZE)*T_HEIGHT+(gy);
                    if(!blockarray[idx1])continue;       
                    if((blockinfo[blockarray[idx1]]&IS_RAMPORSIDE)){
                        hasAnything=TRUE;
                        hasVisy[gy-bounds[1]]=TRUE;
                        
                        face_visibility[(gx-bounds[0])*(CHUNK_SIZE*CHUNK_SIZE)+(gz-bounds[2])*(CHUNK_SIZE)+(gy-bounds[1])]=FACE_ALL;
                        printf("hi\n");
                        continue;
                    }
                    int isvisible=0;            
                    for(int f=0;f<6;f++){
                        int type;
                        type=blockarray[(((gx+dx2[f]+g_offcx)%T_SIZE)*T_SIZE*T_HEIGHT+((gz+dz2[f]+g_offcz)%T_SIZE)*T_HEIGHT+(gy+dy2[f]))%T_BLOCKS];
                        if((gx==0&&dx2[f]>0)||(gz==0&&dz2[f]>0)||(gy==0&&dy2[f]<0))continue;
                        if(blockinfo[type]&IS_NOTSOLID||(f==5&&blockinfo[blockarray[idx1]]&IS_LIQUID&&getLevel(blockarray[idx1])<4)){
                            isvisible|=1<<f;
                            if(blockinfo[type]&IS_ATLAS2){
                                if(blockinfo[type]&IS_LIQUID){
                                    if(blockinfo[type]==blockinfo[blockarray[idx1]]) 
                                        if((f==4||f==5||getLevel(type)>=getLevel(blockarray[idx1]))&&[[World getWorld].terrain getColor:gx :gz :gy]==[[World getWorld].terrain getColor:gx+dx2[f] :gz+dz2[f] :gy+dy2[f]]){
                                            isvisible&=~(1<<f);
                                        }
                                    
                                }else 
                                    if(type==blockarray[idx1]){
                                        if([[World getWorld].terrain getColor:gx :gz :gy]==[[World getWorld].terrain getColor:gx+dx2[f] :gz+dz2[f] :gy+dy2[f]]){
                                            
                                            
                                            isvisible&=~(1<<f);
                                            
                                        }
                                    }
                            }
                        }
                        
                        
                    }
                    if(isvisible){hasAnything=TRUE;
                        hasVisy[gy-bounds[1]]=TRUE;
                    }
                    face_visibility[(gx-bounds[0])*(CHUNK_SIZE*CHUNK_SIZE)+(gz-bounds[2])*(CHUNK_SIZE)+(gy-bounds[1])]=isvisible;
                }
            }
        }       
    }else
        for(int gy=bounds[1];gy<ey;gy++){
            if(!hasBlocky[gy-bounds[1]])continue;
            for(int gx=bounds[0];gx<ex;gx++){
                
                for(int gz=bounds[2];gz<ez;gz++){
                    //if(!gx||!gy||!gz||gx+1==T_HEIGHT||gz+1==T_HEIGHT||gy+1==T_HEIGHT)continue;
                    
                    if(!blockarray[((gx+g_offcx)%T_SIZE)*T_SIZE*T_HEIGHT+((gz+g_offcz)%T_SIZE)*T_HEIGHT+(gy)])continue;                 
                    int isvisible=0;            
                    
                    if((IS_NOTSOLID&blockinfo[blockarray[((gx+g_offcx)%T_SIZE)*T_SIZE*T_HEIGHT+((gz+g_offcz)%T_SIZE)*T_HEIGHT+(gy+1)]]))isvisible|=FACE_TOP; 
                    if((IS_NOTSOLID&blockinfo[blockarray[((gx+g_offcx)%T_SIZE)*T_SIZE*T_HEIGHT+((gz+g_offcz)%T_SIZE)*T_HEIGHT+(gy-1)]]))isvisible|=FACE_BOTTOM;                   
                    if(
                       (IS_NOTSOLID&blockinfo[
                                              blockarray[((gx+1+g_offcx)%T_SIZE)*T_SIZE*T_HEIGHT+((gz+g_offcz)%T_SIZE)*T_HEIGHT+(gy)]
                                              ]
                        ) )isvisible|=FACE_RIGHT;
                    if((IS_NOTSOLID&blockinfo[blockarray[((gx-1+g_offcx)%T_SIZE)*T_SIZE*T_HEIGHT+((gz+g_offcz)%T_SIZE)*T_HEIGHT+(gy)]]))isvisible|=FACE_LEFT;
                    if((IS_NOTSOLID&blockinfo[blockarray[((gx+g_offcx)%T_SIZE)*T_SIZE*T_HEIGHT+((gz+1+g_offcz)%T_SIZE)*T_HEIGHT+(gy)]]))isvisible|=FACE_BACK;
                    if((IS_NOTSOLID&blockinfo[blockarray[((gx+g_offcx)%T_SIZE)*T_SIZE*T_HEIGHT+((gz-1+g_offcz)%T_SIZE)*T_HEIGHT+(gy)]]))isvisible|=FACE_FRONT;                
                    
                    if(isvisible){hasAnything=TRUE;
                        hasVisy[gy-bounds[1]]=TRUE;
                    }
                    face_visibility[(gx-bounds[0])*(CHUNK_SIZE*CHUNK_SIZE)+(gz-bounds[2])*(CHUNK_SIZE)+(gy-bounds[1])]=isvisible;
                }
            }
        }
    
    
    if(bounds[1]==0){
        for(int x=0;x<CHUNK_SIZE;x++)
            for(int z=0;z<CHUNK_SIZE;z++)
                face_visibility[x*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+0]&=~FACE_BOTTOM;
    }else if(bounds[1]+CHUNK_SIZE==T_HEIGHT){
        for(int x=0;x<CHUNK_SIZE;x++)
            for(int z=0;z<CHUNK_SIZE;z++)
                if(blocks[x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+CHUNK_SIZE-1]){
                    face_visibility[x*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+CHUNK_SIZE-1]|=FACE_TOP;
                    hasAnything=TRUE;
                    hasVisy[CHUNK_SIZE-1]=TRUE;
                }
    }
   /* if(bounds[0]==0){
        for(int y=0;y<CHUNK_SIZE;y++)
            for(int z=0;z<CHUNK_SIZE;z++)
                face_visibility[0*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+y]&=~FACE_LEFT;
    }else if(bounds[0]+CHUNK_SIZE==T_SIZE){
        for(int y=0;y<CHUNK_SIZE;y++)
            for(int z=0;z<CHUNK_SIZE;z++)
                face_visibility[(CHUNK_SIZE-1)*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+y]&=~FACE_RIGHT;
    }
    if(bounds[2]==0){
        for(int y=0;y<CHUNK_SIZE;y++)
            for(int x=0;x<CHUNK_SIZE;x++)
                face_visibility[x*(CHUNK_SIZE*CHUNK_SIZE)+0*(CHUNK_SIZE)+y]&=~FACE_FRONT;
    }else if(bounds[2]+CHUNK_SIZE==T_SIZE){
        for(int y=0;y<CHUNK_SIZE;y++)
            for(int x=0;x<CHUNK_SIZE;x++)
                face_visibility[x*(CHUNK_SIZE*CHUNK_SIZE)+(CHUNK_SIZE-1)*(CHUNK_SIZE)+y]&=~FACE_BACK;
        
    }*/
    
    if(!hasAnything){   
        //printf("return early 2\n");
        return;
    }
    
    for(int y=0;y<CHUNK_SIZE;y++){
        if(!hasVisy[y])continue;
        for(int x=0;x<CHUNK_SIZE;x++){		
			for(int z=0;z<CHUNK_SIZE;z++){
                if(!face_visibility[x*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+y])continue;
                
				int type=blocks[x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+y];    
                if((blockinfo[type]&IS_OBJECT)&&
                   !(blockinfo[type]&IS_PORTAL))continue;
                int isvisible=face_visibility[x*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+y];
                
                
                color8 c1=colors[x*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+y];
                
                int d;
                
                for(int f=0;f<6;f++){
                    if(isvisible&(1<<f)){                        
                        if(f==5||f==4||f==0||f==1){//top
                            d=1;
                            
                        }else {
                            d=5;
                        }
                        
                        int size=1;
                        if(!(type>=TYPE_STONE_RAMP1&&type<=TYPE_ICE_SIDE4)&&type!=TYPE_CUSTOM&&!(IS_LIQUID&blockinfo[type])&&!(IS_FLAMMABLE&blockinfo[type]&&isOnFire(x+bounds[0],z+bounds[2],y+bounds[1])))
                            while(1){
                                int nx=x+size*dx[d];
                                int ny=y+size*dy[d];
                                int nz=z+size*dz[d];
                                if(nx<0||ny<0||nz<0||nx>=CHUNK_SIZE||ny>=CHUNK_SIZE||nz>=CHUNK_SIZE)break;
                                int ntype=blocks[nx*CHUNK_SIZE*CHUNK_SIZE+nz*CHUNK_SIZE+ny];
                                if(ntype!=type)break;
                                color8 c2=colors[nx*(CHUNK_SIZE*CHUNK_SIZE)+nz*(CHUNK_SIZE)+ny];
                                if(c1!=c2)break;
                                if(!(face_visibility[nx*(CHUNK_SIZE*CHUNK_SIZE)+nz*(CHUNK_SIZE)+ny]&(1<<f))){
                                    break;
                                }
                                if(!
                                   v_equals(lighting[nx*(CHUNK_SIZE*CHUNK_SIZE)+nz*(CHUNK_SIZE)+ny],lighting[x*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+y]))break;
                                if(f==5&&getShadow(x+bounds[0],z+bounds[2],y+bounds[1])!=getShadow(nx+bounds[0],nz+bounds[2],ny+bounds[1]))break;            
                                
                                face_visibility[nx*(CHUNK_SIZE*CHUNK_SIZE)+nz*(CHUNK_SIZE)+ny]&=~(1<<f);
                                
                                size++;
                                if(size>32)break;
                            }
                        face_size[x*(CHUNK_SIZE*CHUNK_SIZE*6)+z*(CHUNK_SIZE*6)+y*6+f]=size;
                    }
                }
				
			}
		}
	}
    int objidx=0;
    if(num_objects>0){
        objects=malloc(sizeof(StaticObject)*num_objects);
    }
    for(int y=0;y<CHUNK_SIZE;y++){
        if(!hasVisy[y])continue;
        for(int x=0;x<CHUNK_SIZE;x++){
            
			for(int z=0;z<CHUNK_SIZE;z++){
                if(!face_visibility[x*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+y])continue; 
                
                int type=blocks[x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+y];                
                int isvisible=face_visibility[x*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+y];
                if(blockinfo[type]&IS_PORTAL){
                    if(type==TYPE_PORTAL_TOP){
                        objects[objidx].color=colors[x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+y];
                        objects[objidx].open=FALSE;
                        objects[objidx].type=TYPE_PORTAL_TOP;
                        objects[objidx].dir=getLandc(x+bounds[0],z+bounds[2],y+bounds[1]-1)-TYPE_PORTAL1;
                        objects[objidx].pos[0]=x+bounds[0];
                        objects[objidx].pos[1]=y-1+bounds[1];
                        objects[objidx].pos[2]=z+bounds[2];
                        
                        
                        objidx++;
                    }
                    for(int f=0;f<6;f++){	
                        
                        if( isvisible&(1<<f) ){
                            n_vertices+=6;
                            
                            num_vertices[f]+=6;
                        }
                    }
                    
                    
                }else
                    if(blockinfo[type]&IS_OBJECT){
                        
                        face_visibility[x*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+y]=0;
                        if(type==TYPE_DOOR_TOP){
                            objects[objidx].color=colors[x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+y];
                            objects[objidx].open=FALSE;
                            objects[objidx].type=TYPE_DOOR_TOP;
                            objects[objidx].dir=getLandc(x+bounds[0],z+bounds[2],y+bounds[1]-1)-TYPE_DOOR1;
                            objects[objidx].pos[0]=x+bounds[0];
                            objects[objidx].pos[1]=y-1+bounds[1];
                            objects[objidx].pos[2]=z+bounds[2];
                            
                            objidx++;
                        }else if(type==TYPE_GOLDEN_CUBE){
                            objects[objidx].color=colors[x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+y];
                            objects[objidx].open=FALSE;
                            objects[objidx].type=TYPE_GOLDEN_CUBE;
                            objects[objidx].dir=0;
                            objects[objidx].pos[0]=x+bounds[0];
                            objects[objidx].pos[1]=y+bounds[1];
                            objects[objidx].pos[2]=z+bounds[2];
                            
                            objidx++;
                        }else if(type==TYPE_FLOWER){
                            objects[objidx].color=colors[x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+y];
                            objects[objidx].open=FALSE;
                            objects[objidx].type=TYPE_FLOWER;
                            objects[objidx].dir=0;
                            objects[objidx].pos[0]=x+bounds[0];
                            objects[objidx].pos[1]=y+bounds[1];
                            objects[objidx].pos[2]=z+bounds[2];
                            
                            objidx++;
                            
                        }
                    }else
                        if(blockinfo[type]&IS_ATLAS2){
                            for(int f=0;f<6;f++){		
                                if( isvisible&(1<<f) ){
                                    n_vertices2+=6;                          
                                    num_vertices2[f]+=6;
                                }
                            }
                            
                            
                        } else if(type==TYPE_CUSTOM)       {
                            
                            face_visibility[x*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+y]=FACE_ALL;
                            SmallBlock* sb=sblocks[ x*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+y];
                            for(int i=0;i<8;i++){
                                int type2=sb->blocks[i];  
                                
                                if(type2<=0||(blockinfo[type2]&IS_OBJECT))continue;
                                if(blockinfo[type2]&IS_ATLAS2){
                                    for(int f=0;f<6;f++){		
                                        
                                        n_vertices2+=6;                          
                                        num_vertices2[f]+=6;
                                        
                                    }
                                    
                                    
                                }else{
                                    for(int f=0;f<6;f++){	
                                        
                                        
                                        n_vertices+=6;
                                        if(type2>=TYPE_STONE_RAMP1&&type2<=TYPE_ICE_SIDE4&&f==angledFace[type2-TYPE_STONE_RAMP1])
                                            num_vertices[6]+=6;                
                                        else
                                            num_vertices[f]+=6;
                                        
                                    }
                                }
                            }
                        }else{
                            if(type>=TYPE_STONE_RAMP1&&type<=TYPE_ICE_SIDE4){
                                isvisible|=(1<<angledFace[type-TYPE_STONE_RAMP1]);
                                face_visibility[x*(CHUNK_SIZE*CHUNK_SIZE)+z*(CHUNK_SIZE)+y]=isvisible;
                            }
                            for(int f=0;f<6;f++){	
                                
                                if( isvisible&(1<<f) ){
                                    n_vertices+=6;
                                    if(type>=TYPE_STONE_RAMP1&&type<=TYPE_ICE_SIDE4&&f==angledFace[type-TYPE_STONE_RAMP1])
                                        num_vertices[6]+=6;                
                                    else
                                        num_vertices[f]+=6;
                                }
                            }
                            
                            
                            
                        }
            }
		}
	}
    verticesbg=malloc(sizeof(vertexStructSmall)*n_vertices);
    verticesbg2=malloc(sizeof(vertexStructSmall)*n_vertices2);
    if(objidx<num_objects)num_objects=objidx;
    if(num_objects>0){
        //printf("%d doors in this chunk \n",num_objects);
    }
    if(!n_vertices&&!n_vertices2){//printf("return early 3\n");
        return;}
    for(int i=1;i<7;i++){       
        face_idx[i]=num_vertices[i-1]+face_idx[i-1];
        face_idx2[i]=num_vertices2[i-1]+face_idx2[i-1];
        
    }
    
    Resources* res=[Resources getResources];
	for(int idx=0;idx<CHUNK_SIZE3;idx++){
        if(!face_visibility[idx])continue;
        
        int isvisible=face_visibility[idx];        
        int type=blocks[idx];
        int y=idx%CHUNK_SIZE;
        int z=(idx/CHUNK_SIZE)%CHUNK_SIZE;
        int x=(idx/CHUNK_SIZE2)%CHUNK_SIZE;        
        
        BOOL burned=FALSE;
        if(IS_FLAMMABLE&blockinfo[type]&&isOnFire(x+bounds[0],z+bounds[2],y+bounds[1])){
            burned=TRUE;
        }
        
        
        short offsets[3];
        offsets[0]=x;
        offsets[1]=y;
        offsets[2]=z;	
        
        if(type==TYPE_CUSTOM){
            // printf("isvisible %d\n",isvisible);
            
            SmallBlock* sb=sblocks[idx];
            for(int ci=0;ci<8;ci++){
                if(sb->blocks[ci]!=0){
                    int offsets2[3];
                    if(ci%2==0)offsets2[1]=2;
                    else offsets2[1]=0;
                    
                    if((ci/2)%2==0)offsets2[2]=2;
                    else offsets2[2]=0;
                    
                    if((ci/4)%2==0)offsets2[0]=2;
                    else offsets2[0]=0;
                    
                    float paint[3];
                    float light[3];
                    int type=sb->blocks[ci];
                    if(type==0)continue;
                    color8 clr=sb->colors[ci];                    
                    BOOL coloring=false;
                    BOOL isLiquid=false;
                    Vector cl=colorTable[clr];
                    paint[0]=cl.x;
                    paint[1]=cl.y;
                    paint[2]=cl.z;
                    Vector lightv=lighting[(x)*CHUNK_SIZE*CHUNK_SIZE+(z)*CHUNK_SIZE+(y)];
                    light[0]=lightv.x;
                    light[1]=lightv.y;
                    light[2]=lightv.z;
                    //if(light[0]!=0||light[1]!=0||light[2]!=0)
                    // printf("lighting at(%d,%d,%d),  (%f,%f,%f)\n",x,y,z,light[0],light[1],light[2]);
                    //int corners[4]={4,4,4,4};
                    int top_shadow=255;
                    if(FACE_TOP&isvisible){
                        top_shadow-=getShadow(x+bounds[0],z+bounds[2],y+bounds[1]);
                    }
                    // if(top_shadow!=255)NSLog(@"yay");
                    vertexStructSmall* vert_array=verticesbg;
                    int vert_c=v_idx;
                    //NSLog(@"v_idx: %d, nvert:%d",v_idx,n_vertices);
                    BOOL is2=FALSE;
                    if(blockinfo[type]&IS_ATLAS2){
                        is2=TRUE;
                        vert_array=verticesbg2;
                        vert_c=v_idx2;
                    }
                    
                    int rtype;
                    int sideface=-1;
                    int wshadow=80;
                    
                    int specialFace=-1;
                    
                    int gshadows[8]={235,178,191,223,  204, 159,127, 160,  };
                    if((type>=TYPE_STONE_RAMP1&&type<=TYPE_ICE_SIDE4)){
                        specialFace=angledFace[type-TYPE_STONE_RAMP1];
                        rtype=type%4;
                        if(type>=TYPE_STONE_SIDE1)rtype+=4;
                        wshadow=gshadows[rtype];
                        sideface=specialFace;
                        
                        
                        //corners[0]=corners[1]=corners[2]=corners[3]=0;
                        if((type>=TYPE_STONE_RAMP1&&type<=TYPE_ICE_RAMP4))
                            top_shadow=( wshadow )/255.0f*top_shadow;
                    }
                    
                    if(clr==0){
                        if(type==TYPE_GRASS||type==TYPE_GRASS2||type==TYPE_GRASS3||type==TYPE_TNT||type==TYPE_FIREWORK||type==TYPE_BRICK||type==TYPE_VINE||type==TYPE_TRAMPOLINE){
                            coloring=TRUE;
                        }
                        for(int i=0;i<3;i++)
                            paint[i]=(float)blockColor[type][i]/255;
                    }
                    const GLshort* cubeVertices=cubeShortVertices;
                    const GLshort* cubeTextureCustom=cubeTexture;
                    if(blockinfo[type]&IS_LIQUID){
                        isLiquid=TRUE;
                        int level=getLevel(type);
                        int maxlevel=0;
                        int maxleveld=0;
                        for(int f=0;f<6;f++){
                            if(!( isvisible&(1<<f) ) ){
                                if(f!=4&&f!=5){
                                    int type2=getLandc((bounds[0]+x+dx2[f]),(bounds[2]+z+dz2[f]),(bounds[1]+y+dy2[f]));
                                    int level2=getLevel(type2);
                                    if(level2>maxlevel){
                                        maxlevel=level2;
                                        maxleveld=f;
                                    }
                                }
                                continue;
                            }
                            int sf=f*6*3;
                            if(f!=4&&f!=5){
                                int type2=getLandc(bounds[0]+x+dx2[f],(bounds[2]+z+dz2[f]),(bounds[1]+y+dy2[f]));
                                int level2=getLevel(type2);
                                if(level2<level){
                                    if(getBaseType(type2)==getBaseType(type)){
                                        
                                        if(level2>maxlevel){
                                            maxlevel=level2;
                                            maxleveld=f;
                                        }
                                    }
                                }else level2=level;
                                
                                
                                
                                for(int v=0;v<6;v++){
                                    int sv=sf+v*3;
                                    
                                    
                                    
                                    if(cubeShortVertices[sv+1]){
                                        liquidCube[sv+1]=level;
                                    }else{
                                        liquidCube[sv+1]=level2;
                                    }
                                    
                                    
                                }
                                
                            }else{
                                for(int v=0;v<6;v++){
                                    int sv=sf+v*3;
                                    
                                    
                                    
                                    if(cubeShortVertices[sv+1]){
                                        liquidCube[sv+1]=level;
                                    }
                                    
                                    
                                }  
                            }
                            
                        }
                        
                        if(maxlevel==level)maxleveld=0;
                        if(maxlevel<level)maxleveld=(2+maxleveld)%4;
                        const GLshort* cubeVerticesTop;
                        //  printf("maxleveld:%d",maxleveld);
                        if(maxleveld==0){                
                            cubeVerticesTop=side3Texture;
                        }else if(maxleveld==1){               
                            cubeVerticesTop=side1Texture;
                        }else if(maxleveld==2){               
                            cubeVerticesTop=side2Texture;
                        }else if(maxleveld==3){               
                            cubeVerticesTop=side4Texture;
                        }
                        
                        for(int v=0;v<6;v++){
                            for(int coord=0;coord<2;coord++){
                                
                                liquidTexture[5*6*2+v*2+coord]=cubeVerticesTop[5*6*2+v*2+coord];
                                
                            }
                        }
                        
                        cubeTextureCustom=liquidTexture;
                        
                        
                    }else 
                        if(type>=TYPE_STONE_SIDE1&&type<=TYPE_ICE_SIDE4){
                            
                            if(type%4==0){
                                cubeVertices=side1ShortVertices;
                                cubeTextureCustom=side1Texture;
                            }else if((type+1)%4==0){
                                cubeVertices=side2ShortVertices;
                                cubeTextureCustom=side2Texture;
                            }else if((type+2)%4==0){
                                cubeVertices=side3ShortVertices;
                                cubeTextureCustom=side3Texture;
                            }else if((type+3)%4==0){
                                cubeVertices=side4ShortVertices;
                                cubeTextureCustom=side4Texture;
                            }
                            
                        }else if(type>=TYPE_STONE_RAMP1&&type<=TYPE_ICE_RAMP4){
                            if(type%4==0){
                                cubeVertices=ramp1ShortVertices;
                                cubeTextureCustom=ramp1Texture;
                            }else if((type+1)%4==0){
                                cubeVertices=ramp2ShortVertices;
                                cubeTextureCustom=ramp2Texture;
                            }else if((type+2)%4==0){
                                cubeVertices=ramp3ShortVertices;
                                cubeTextureCustom=ramp3Texture;
                            }else if((type+3)%4==0){
                                cubeVertices=ramp4ShortVertices;
                                cubeTextureCustom=ramp4Texture;
                            }
                            
                        }
                    
                    for(int f=0;f<6;f++){
                        if(!( isvisible&(1<<f) ) )continue;
                        int size=face_size[x*(CHUNK_SIZE*CHUNK_SIZE*6)+z*(CHUNK_SIZE*6)+y*6+f];
                        int mergeAxis;
                        if(f==5||f==4||f==0||f==1){
                            mergeAxis=0;
                        }else{
                            mergeAxis=2;
                        }
                        
                        
                        if(!is2){
                            if(f==specialFace){
                                vert_c=face_idx[6];
                                face_idx[6]+=6;
                            }else{
                                vert_c=face_idx[f];
                                face_idx[f]+=6;  
                            }
                        }else{
                            vert_c=face_idx2[f];
                            face_idx2[f]+=6;  
                            
                        }
                        
                        int sf=f*6*3;
                        
                        int bf=blockTypeFaces[type][f];
                        if(coloring){
                            for(int i=0;i<3;i++)
                                paint[i]=1.0f;
                            
                            if(bf==TEX_GRASS_TOP||bf==TEX_GRASS_TOP2)
                            {
                                
                                
                                for(int i=0;i<3;i++){
                                    paint[i]=(float)(blockColor[type][i])/255;
                                    if(paint[i]<0)paint[i]=0;
                                }
                            }
                            else if(bf==TEX_GRASS_SIDE)
                                bf=TEX_GRASS_SIDE_COLOR;
                            else if(bf==TEX_TNT_SIDE)
                                bf=TEX_TNT_SIDE_COLOR;
                            else if(bf==TEX_TNT_TOP)
                                bf=TEX_TNT_TOP_COLOR;
                            else if(bf==TEX_BRICK)
                                bf=TEX_BRICK_COLOR;
                            else if(bf==TEX_DIRT){
                                for(int i=0;i<3;i++)
                                    paint[i]=(float)blockColor[TEX_DIRT][i]/255;
                            }else if(!(blockinfo[type]&IS_LIQUID)&&type!=TYPE_VINE){
                                for(int i=0;i<3;i++)
                                    paint[i]=(float)blockColor[type][i]/255;
                            }
                            
                        }
                        if(type!=TYPE_LIGHTBOX)
                            for(int i=0;i<3;i++){
                                
                                float n=light[i]+paint[i]*4.0f/5.0f;
                                if(n<=paint[i])paint[i]=n;
                                
                            }
                        CGPoint tp;
                        tp=[res getBlockTexShort:bf];
                        
                        
                        
                        for(int v=0;v<6;v++){
                            int sv=sf+v*3;
                            for(int coord=0;coord<3;coord++){
                                
                                
                                if(isLiquid){
                                    vert_array[vert_c].position[coord]=liquidCube[sv+coord]/2+4*offsets[coord]+offsets2[coord];
                                    
                                }else if(coord==mergeAxis){
                                    
                                    vert_array[vert_c].position[coord]=2*cubeVertices[sv+coord]*size+4*offsets[coord]+offsets2[coord];
                                    
                                }
                                else{
                                    vert_array[vert_c].position[coord]=2*cubeVertices[sv+coord]+4*offsets[coord]+offsets2[coord];                    
                                }
                                int color;
                                if(type==TYPE_CLOUD&&f==4)
                                    color=paint[coord]*180;                           